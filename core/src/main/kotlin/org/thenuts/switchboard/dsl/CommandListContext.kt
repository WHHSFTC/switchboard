package org.thenuts.switchboard.dsl

import org.thenuts.switchboard.command.*
import org.thenuts.switchboard.command.atomic.*
import org.thenuts.switchboard.command.combinator.*
import org.thenuts.switchboard.util.Frame
import kotlin.time.Duration

@CommandDsl
class CommandListContext(val strict: Boolean = false) {
    private val list: MutableList<Command> = mutableListOf()

    /**
     * Adds a [Command] to the list.
     */
    fun add(cmd: Command): CommandListContext {
        list += if (strict) StrictCommand(cmd) else cmd
        return this
    }

    /**
     * Adds a [SwitchCommand] that chooses which branch to execute based on the [supplier].
     */
    fun <T> switch(supplier: () -> T, block: SwitchCommandContext<T>.() -> Unit): CommandListContext {
        add(mkSwitch(strict, supplier, block))
        return this
    }

    /**
     * Adds an [AwaitCommand] that is done when the [predicate] returns true.
     */
    fun await(predicate: (Frame) -> Boolean): CommandListContext {
        add(AwaitCommand(predicate))
        return this
    }

    /**
     * Adds a [ParallelCommand] that is done when all of the predicates have returned true.
     */
    fun awaitAll(vararg predicate: (Frame) -> Boolean): CommandListContext {
        add(ParallelCommand(predicate.asList().map { AwaitCommand(it) }, awaitAll = true))
        return this
    }

    /**
     * Adds a [ParallelCommand] that is done when any of the predicates returns true.
     */
    fun awaitAny(vararg predicate: (Frame) -> Boolean): CommandListContext {
        add(ParallelCommand(predicate.asList().map { AwaitCommand(it) }, awaitAll = false))
        return this
    }

    /**
     * Adds a [ParallelCommand] containing an that is done when the [predicate] returns true or
     * when the [timeout] is up, whichever comes first.
     */
    fun awaitUntil(timeout: Duration, predicate: (Frame) -> Boolean): CommandListContext {
        this.par(awaitAll = false) {
            await(predicate)
            delay(timeout)
        }
        return this
    }

    /**
     * Adds a [DelayCommand] that is done when the [duration] is up.
     */
    fun delay(duration: Duration): CommandListContext {
        add(DelayCommand(duration))
        return this
    }

    /**
     * Adds a [LinearCommand] that runs [block] asynchronously.
     */
    fun linear(finally: () -> Unit = { }, block: suspend LinearContext.() -> Unit): CommandListContext {
        add(LinearCommand(block, finally))
        return this
    }

    /**
     * Adds a [SequentialCommand] containing [n] generated commands from the [block].
     */
    fun times(n: Int, block: CommandListContext.() -> Unit): CommandListContext {
        seq { repeat(n) { seq(block) } }
        return this
    }

    /**
     * Adds a [SimpleCommand] that only calls the function [f].
     */
    fun task(f: (Frame) -> Unit): CommandListContext {
        add(SimpleCommand(f))
        return this
    }

    /**
     * Adds a [SequentialCommand] that runs the list of commands generated by [block] one by one.
     */
    fun seq(block: CommandListContext.() -> Unit): CommandListContext {
        add(mkSequential(strict, block))
        return this
    }

    /**
     * Adds a [ParallelCommand] that runs the list of commands generated by [block] simultaneously.
     *
     * @param awaitAll If `true`, wait for all subcommands to finish; if `false`, interrupt
     * remaining subcommands after any one finishes.
     */
    fun par(awaitAll: Boolean = true, block: CommandListContext.() -> Unit): CommandListContext {
        add(mkParallel(strict, awaitAll, block))
        return this
    }

    /**
     * Adds a [LoopCommand] that generates and runs commands from [block] **at runtime** while
     * [predicate] returns true. If [interrupt] is true, it will check every update, instead of at
     * the top of every longer loop iteration.
     *
     * Runtime generation of commands has the potential to be very slow. Moving slow operations such
     * as trajectory generation out of [block] is recommended. If there is a reasonable upper bound
     * to the number of iterations, consider using [times] to generate each iteration beforehand.
     */
    fun loop(predicate: (Frame) -> Boolean, interrupt: Boolean = false, block: CommandListContext.() -> Unit): CommandListContext {
        add(mkLoop(strict, predicate, interrupt, block))
        return this
    }

    /**
     * Adds a [LoopCommand] that generates and runs commands from [block] **at runtime** while
     * [predicate] returns false. If [interrupt] is true, it will check every update, instead of at
     * the top of every longer loop iteration.
     *
     * See [loop] for important performance warnings.
     */
    fun until(predicate: (Frame) -> Boolean, interrupt: Boolean = false, block: CommandListContext.() -> Unit): CommandListContext {
        loop({ !predicate(it) }, interrupt, block)
        return this
    }

    /**
     * Adds a [LoopCommand] that generates and runs commands from [block] **at runtime** forever.
     *
     * See [loop] for important performance warnings.
     */
    fun forever(block: CommandListContext.() -> Unit): CommandListContext {
        loop({ true }, interrupt = false, block)
        return this
    }

    internal fun build() = list

    internal fun buildSequential() = SequentialCommand(list)

    internal fun buildParallel(awaitAll: Boolean) = ParallelCommand(list, awaitAll)
}

/**
 * Constructs a [LinearCommand] that will evaluate a [block] asynchronously.
 *
 * @param finally Callback to cleanup command.
 * @param block Asynchronous function to evaluate.
 */
fun mkLinear(finally: () -> Unit = { }, block: suspend LinearContext.() -> Unit): Command
    = LinearCommand(block, finally)

/**
 * Constructs a [SequentialCommand] that will evaluate a list of commands from [block] one by one.
 *
 * @param strict Whether to place [StrictCommand] wrappers to catch lifecycle bugs.
 * @param block Block to populate a list of commands using the Command DSL.
 */
fun mkSequential(strict: Boolean = false, block: CommandListContext.() -> Unit): Command
        = CommandListContext(strict).apply(block).buildSequential()

/**
 * Constructs a [ParallelCommand] that will evaluate a list of commands from [block]
 * simultaneously.
 *
 * @param strict Whether to place [StrictCommand] wrappers to catch lifecycle bugs.
 * @param awaitAll If `true`, wait for all subcommands to finish; if `false`, interrupt
 * remaining subcommands after any one finishes.
 * @param block Block to populate a list of commands using the Command DSL.
 */
fun mkParallel(strict: Boolean = false, awaitAll: Boolean = true, block: CommandListContext.() -> Unit): Command
        = CommandListContext(strict).apply(block).buildParallel(awaitAll)

/**
 * Constructs a [LoopCommand] that generates and runs commands from [block] **at runtime** forever.
 *
 * @param strict Whether to place [StrictCommand] wrappers to catch lifecycle bugs.
 * @param predicate When this returns false, the loop is ended.
 * @param interrupt If `true`, check [predicate] on every update; if `false`, check [predicate] only
 * at top of each longer loop cycle.
 * @param block Block to populate a list of commands using the Command DSL.
 */
fun mkLoop(strict: Boolean = false, predicate: (Frame) -> Boolean, interrupt: Boolean = false, block: CommandListContext.() -> Unit): Command
        = LoopCommand(predicate, interrupt) { mkSequential(strict, block) }
